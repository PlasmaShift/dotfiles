#!/usr/bin/env perl

use 5.20.1;
use warnings;
use IO::All;
use JSON::MaybeXS 'decode_json';
use Linux::Inotify2;
use AnyEvent;

$|++;

use experimental 'postderef';
my $config = shift;
my @watches = decode_json(io->file($config)->all)->@*;

my @watchers;

my $inotify = new Linux::Inotify2
   or die "unable to create new inotify object: $!";

my $mask = IN_MODIFY | IN_ATTRIB | IN_MOVED_TO | IN_CREATE | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF;

my %timeouts;

while (my ($dirs, $svcs) = splice @watches, 0, 2) {

   for my $outer_dir (@$dirs) {

      my $cb = sub {
         my $e = shift;

         $timeouts{$outer_dir} = AnyEvent->timer(
            after => $ENV{MINOTAUR_DEBOUNCE} || 0.5,
            cb => sub {
               for my $service (@$svcs) {
                  my $svc_dir = io->dir("$ENV{SVDIR}/$service/supervise");

                  if ($svc_dir->file('stat')->all =~ /run/) {
                     say "restarting service: $service";
                     $svc_dir->file('control')
                        ->print('tcu') # sigTerm, sigCont, "Up"
                  }
               }
               delete $timeouts{$outer_dir}
            },
         );
      };

      for my $dir (io->dir($outer_dir)->All_Dirs) {
         say "watching $dir";
         $inotify->watch ($dir, $mask, $cb)
            or die "unable to create new inotify object: $!";
      }

   }
}

my $done = AnyEvent->condvar;

$inotify->watch(
   $config, $mask, sub { say "config modified, restarting"; $done->send }
);

my $inotify_w = AnyEvent->io (
   fh => $inotify->fileno,
   poll => 'r',
   cb => sub { $inotify->poll } # runs callbacks defined above
);

$done->recv;
